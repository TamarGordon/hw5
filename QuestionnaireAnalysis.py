Copy code
from typing import Union
import json
import pathlib
import numpy as np
import matplotlib.pyplot as plt

class QuestionnaireAnalysis:
    """
    Reads and analyzes data generated by the questionnaire experiment.
    Should be able to accept strings and pathlib.Path objects.
    """

    def __init__(self, data_fname: Union[pathlib.Path, str]):
        self.data_fname = data_fname
        self.data = None

    def read_data(self):
        """Reads the json data located in self.data_fname into memory, to
        the attribute self.data.
        """
        if isinstance(self.data_fname, pathlib.Path):
            self.data_fname = str(self.data_fname)

        with open(self.data_fname, 'r') as file:
            self.data = json.load(file)

    def show_age_distrib(self) -> Tuple[np.ndarray, np.ndarray]:
        """Calculates and plots the age distribution of the participants.
        
        Returns
        -------
        hist : np.ndarray
            Number of people in a given bin
        bins : np.ndarray
            Bin edges
        """
        # Assuming 'age' is a key in the data dictionary
        ages = [participant['age'] for participant in self.data]

        bins = np.arange(0, 101, 10)  # This creates bins from 0 to 100 with a step of 10.
        hist, bins = np.histogram(ages, bins)

        plt.figure(figsize=(10, 6))  # Creates a new figure
        plt.hist(ages, bins, edgecolor='black')  # Plots a histogram of ages

        plt.title('Age Distribution')  # Adds a title to the figure
        plt.xlabel('Age')  # Adds a label to the x-axis
        plt.ylabel('Number of Participants')  # Adds a label to the y-axis

        plt.show()  # Displays the figure

        return hist, bins
    

    def remove_rows_without_mail(self) -> pd.DataFrame:
        """Checks self.data for rows with invalid emails, and removes them.

        Returns
        -------
        df : pd.DataFrame
          A corrected DataFrame, i.e., the same table but with the erroneous rows removed and
          the (ordinal) index after a reset.
        """
        # Convert the list of dictionaries to a DataFrame
        df = pd.DataFrame(self.data)

        # Define a function that checks if an email is valid
        def is_valid_email(email):
            if "@" not in email or email.startswith("@") or email.endswith("@"):
                return False
            if "." not in email or email.startswith(".") or email.endswith("."):
                return False
            if email[email.index("@") + 1] == ".":
                return False
            return True

        # Apply the function to the 'email' column to get a Series of True/False values
        valid_emails = df['email'].apply(is_valid_email)

        # Keep only the rows where valid_emails is True
        df = df[valid_emails]

        # Reset the index and return the DataFrame
        return df.reset_index(drop=True)
    

    def fill_na_with_mean(self) -> Tuple[pd.DataFrame, np.ndarray]:
        """Finds, in the original DataFrame, the subjects that didn't answer
        all questions, and replaces that missing value with the mean of the
        other grades for that student.

        Returns
        -------
        df : pd.DataFrame
          The corrected DataFrame after insertion of the mean grade
        arr : np.ndarray
          Row indices of the students that their new grades were generated
        """
        # Convert the list of dictionaries to a DataFrame
        df = pd.DataFrame(self.data)

        # Find rows with missing values
        missing_rows = df.isnull().any(axis=1)
        arr = np.where(missing_rows)[0]

        # Compute the mean of the non-missing values for each participant (row)
        row_means = df.mean(axis=1)

        # Replace the missing values with the row means
        df = df.apply(lambda row: row.fillna(row_means[row.name]), axis=1)

        return df, arr
   
    def score_subjects(self, maximal_nans_per_sub: int = 1) -> pd.DataFrame:
        """Calculates the average score of a subject and adds a new "score" column with it."""
        # Convert the list of dictionaries to a DataFrame
        df = pd.DataFrame(self.data)
        
        # Count how many missing answers each participant has
        nans_per_sub = df.isnull().sum(axis=1)
        
        # Compute the mean of the non-missing values for each participant
        df['score'] = df.mean(axis=1)
        
        # If a participant has more than maximal_nans_per_sub missing answers, set their score to NaN
        df.loc[nans_per_sub > maximal_nans_per_sub, 'score'] = np.nan

        # Convert scores to integer, rounding down
        df['score'] = df['score'].fillna(-1).astype(int)
        df.loc[df['score'] == -1, 'score'] = np.nan

        return df